#![deny(unsafe_code)]
#![no_main]

//! Fuzz testing for random number generation
//!
//! Tests that random generation functions handle various sizes
//! without crashing and produce unique outputs.

use libfuzzer_sys::fuzz_target;
use arc_primitives::rand::csprng::{random_bytes, random_u32, random_u64};

fuzz_target!(|data: &[u8]| {
    if data.is_empty() {
        return;
    }

    // Use first bytes to determine test parameters
    let size = ((data[0] as usize) % 256) + 1; // 1-256 bytes

    // Test 1: Generate random bytes of specified size
    let random_result: Vec<u8> = random_bytes(size);
    // Verify correct length
    assert_eq!(random_result.len(), size, "Generated bytes must have requested size");

    // Verify not all zeros (with high probability)
    if size >= 16 {
        let all_zero = random_result.iter().all(|&b| b == 0);
        assert!(!all_zero, "Random bytes should not be all zeros (with overwhelming probability)");
    }

    // Test 2: Generate multiple random sequences, verify they differ
    let rand1: Vec<u8> = random_bytes(32);
    let rand2: Vec<u8> = random_bytes(32);
    assert_ne!(
        rand1, rand2,
        "Two random generations should produce different results (with overwhelming probability)"
    );

    // Test 3: Generate various sizes
    for test_size in [1, 16, 32, 64, 128, 256] {
        let random: Vec<u8> = random_bytes(test_size);
        assert_eq!(random.len(), test_size);
    }

    // Test 4: Test random_u32 and random_u64
    let r1 = random_u32();
    let r2 = random_u32();
    // May be equal by chance, but very unlikely with good RNG
    let _ = (r1, r2);

    // Generate random u64
    let r3 = random_u64();
    let r4 = random_u64();
    let _ = (r3, r4);

    // Test 5: Zero size generation
    let empty: Vec<u8> = random_bytes(0);
    assert!(empty.is_empty(), "Zero size should produce empty result");

    // Test 6: Stress test - multiple rapid generations
    for _ in 0..10 {
        let _: Vec<u8> = random_bytes(32);
    }
});
